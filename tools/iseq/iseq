#!/usr/bin/env node

/**
 * The utility tool which used to generate seqencing textual data/diagram for the C/C++ application 
 * which compiled with shared lib calltracer
 *
 * The tool can run on Linux with external dependents, including: addr2line, seqdiag command, and node runtime env.
 *
 * So far, it still not supports other OS
 *
 * @author leezhenghui@gmail.com 
 *
 */
'use strict'

//========================================================
//       Dependened Modules
//========================================================

const program       = require('commander');
const path          = require('path');
const fs            = require('fs');
const Q             = require('q');
const colors        = require('colors');
const debug         = require('debug')('iseq');
const child_process = require('child_process');
const readline      = require('readline');
const Mustache      = require('mustache');
const df            = require('dateformat');

//=========================================================
//     Global Variables
//=========================================================

const ADDR2LINE_CMD = '/usr/bin/addr2line';
const SEQDIAG_CMD = '/usr/bin/seqdiag';
const DIAGRAMS_CMD_LAUNCHER = '/usr/local/bin/node';
const DIAGRAMS_CMD = 'diagrams';
const DIAGRAMS_CMD_CWD = __dirname;
const FLAMEGRAPH_CMD_LAUNCHER = '/usr/bin/perl';
const FLAMEGRAPH_CMD = path.join(__dirname, 'deps/FlameGraph', 'flamegraph.pl');

const DEFAULT_NUMBER_RADIX = 16;

const DIAG_LINE_COLORS = ['blue', 'green', 'orange'];
const DIAG_LINE_ERROR_COLOR = 'red';

const TEMPLATE_PATH = path.join(__dirname, 'templates/seqdiag.mustache');
const DIAGRAMS_TEMPLATE_PATH = path.join(__dirname, 'templates/diagrams.mustache');
const STACKCOLLAPSE_TEMPLATE_PATH = path.join(__dirname, 'templates/stackcollapse.mustache');

const OUT_SEQ_DESC_FILE = 'seqdiag.desc';
const OUT_SEQ_DIAGRAMS_DESC_FILE = 'diagrams.desc';
const OUT_SEQ_STACKCOLLAPSE_DESC_FILE = 'stackcollapse.desc';

const OUT_SEQ_PNG_FILE = 'seqdiag.png';
const OUT_SEQ_SVG_FILE = 'diagrams.svg';
const OUT_SEQ_FLAMEGRAPH_FILE = 'flamegraph.svg';

const OUT_SEQ_JSON_FILE = 'seqdiag.json';
const OUT_SEQ_DIAGRAMS_JSON_FILE = 'diagrams.json';
const OUT_SEQ_STACKCOLLAPSE_JSON_FILE = 'stackcollapse.json';

const DEFAULT_JOB_PRIORITY = 300;
const DEFAULT_DATEFOMRAT_PATTERN = 'm/d/yy h:m:s l';

const TRACE_FILE_PATTERN = /^cst-(:?[0-9]+)+\.log$/g

//==========================================================
//  Class/Utility Definitions
//==========================================================

let colorCursor = 0;

let getDiffColor = function getDiffColor(previousColor) {

	let nextColor = (colorCursor + 1) % DIAG_LINE_COLORS.length;

	if (previousColor && DIAG_LINE_COLORS[nextColor] === previousColor) {
		return DIAG_LINE_COLORS[colorCursor];
	}

	colorCursor = nextColor;

	return DIAG_LINE_COLORS[colorCursor];
}

class CMDExecutor {
	constructor(cmd, cwd, opts) {
		this.cmd = cmd;
		this.cwd = cwd;
		this.opts = opts || {};
	}

	/**
	 * Execute a shell command and return the stdout/stderror back as the execution result
	 *
	 * @params [<String>], the command execution parameters
	 *
	 * @callback func
	 *
	 * @return Promise, resolve: String, reject: String
	 *
	 */
	exec(params, callback) {
		let defer = Q.defer();
		let self = this;

		try {
			let runner = child_process.spawn(self.cmd, params, {'cwd': self.cwd || process.cwd(), stdio: self.opts.stdio || 'pipe'});

			let reval = '';
			let fault = '';

			runner.on('close', function() {
			  // debug('Run cmd "' + self.cmd + '" with params: ', params, ' and result: ', reval);
				defer.resolve(reval);
			});

			if (runner.stdout) {
				runner.stdout.on('data', function (data) {
					reval += data;
				});
			}

			runner.stderr.on('data', function (data) {
				fault += data;
			});

			runner.on('error', function(error) {
				console.error('Failed to run cmd "' + self.cmd + '" with params: ', params, ' due to: ', error);
				defer.reject({
			    reason: fault,
					details: error
				});
			});
		} catch(error) {
			console.error('Failed to launch cmd "' + self.cmd + '" with params: ', params, ' due to: ', error);
			defer.reject({ details: error, reason: 'Failed to launch cmd "' + self.cmd + '" with params: "' + JSON.stringify(params) + '"'});
		}

		return defer.promise.nodeify(callback);
	}
}


/**
 * The line in the call stack trace log
 *
 */
class Line {
	constructor (position, logFile, rawContent) {
		this.position = position;
		this.rawContent = rawContent;
		this.logFile = logFile;
		this.parser = null;
		this.isParserResolved = false;
	}

	getPosition() {
    return this.position;	
	}

	getLogFile() {
    return this.logFile;	
	}

	getContent() {
    return this.rawContent;	
	}

	getParser(){
		const self = this;
		if (! self.isParserResolved) {
			self.parser = LineProcessor.resolveParser(self); 
			self.isParserResolved = true;
		}
    return self.parser;	
	}
}

/**
 * The port is used to present source or target which participating in the interaction
 *
 * It is a function description in call stack trace
 *
 */
class Port {

	constructor(funcName, srcLoc, execPoint, addr, image) {
		this.funcName = funcName;
		this.srcLoc = srcLoc;
		this.execPoint = execPoint;
		this.addr = addr;
		if ('string' === typeof this.addr) {
	     this.addr = parseInt(this.addr, DEFAULT_NUMBER_RADIX); 	
		}
		this.image = image;
	}
	
	static get QNAME() {
		return 'PortParser';
	}

	static get Priority() {
    return 300;	
	}
	
	static getOffsetInDL(addr, image) {
		let offset = 0;
		if (! image.isSharedLib()) {
			return null;
		}

		if ('string' === typeof addr) {
			addr = parseInt(addr, DEFAULT_NUMBER_RADIX);	
		}	
		offset = addr - image.getVMAStartAddr(); 
		offset = new Number(offset);
		return offset.toString(DEFAULT_NUMBER_RADIX);
	}

	static get ADDR_TO_LINE_PATTERN() {	
		return /^\s*((?:\S+\s*(?!at)\S*)*)\s+(?:at)*\s*(\S+):([0-9\?]+)(?:\s+\S*\s*)*$/g;
	}

	/**
	 * @param opts, {
	 *   image: <Object> // func owner image for the addr
	 * }
	 *
	 * addr2line result formats:
	 * 
	 * [1] The code is compiled with debug info, we can see the detailed symbol info 
	 *
	 * <method> at <src_loc>:<line>
	 *
	 * e.g:
	 *
	 * log at /home/lizh/playground/calltracer/out/../examples/example.c:27
	 *
	 * [2] Only can see the func name, no source code and line info. This usually happen the code was missing debug info.
	 *
	 * <method> at ??:?
	 *
	 * e.g: 
	 *
	 * _start at ??:?
	 *
	 * [3] Can't find any symbol on the given addr and image file
	 *
	 * ?? ??:0
	 *
	 *
	 * @return promise
	 */
	static parse(addr, opts, callback) {

		let portInCache = opts.image.getPort(addr);
		if (portInCache) {
	    return Q(portInCache).nodeify(callback);	
		}

		let addr2line = new CMDExecutor(ADDR2LINE_CMD);
		let fixedAddr = Port.getOffsetInDL(addr, opts.image) || addr;
		let params = ['-fp', '-e', opts.image.getFullPath(), fixedAddr];

		return addr2line.exec(params).then(function(output) {
			debug('Run addr2line command,  params:\n', params, '\n output:\n', '"' + output + '"');

			if (! Port.ADDR_TO_LINE_PATTERN.test(output)) {
				console.error('Unrecognized addr2line command output: ', output);
				throw {
					errorCode: 'E_ADDR2LINE_220',
			    reason: 'Unrecognized addr2line command output: ' + output
				};
			}

			let parsedOutput = Port.ADDR_TO_LINE_PATTERN.exec(output);
			let funcName = parsedOutput[1];
			let srcLoc = parsedOutput[2];
			let execPoint = parsedOutput[3];
			let reval = new Port(funcName, srcLoc, execPoint, addr, opts.image);
			opts.image.setPort(addr, reval);
			if (! opts.part.firstParticipatePort) {
				opts.part.setFirstParticipatePort(reval);
			} else {
				opts.part.setLastParticipatePort(reval);
			}
			return reval;
		}).nodeify(callback);
	}

	equalsTo(port) {
		if (! port) {
			return false;	
		}

		if (port.addr && port.addr === this.addr) {
			return true;
		}

		return false;
	}
	
	getVMA() {
		let self = this;
    if ('string' === typeof self.addr) {
	    return parseInt(self.addr, DEFAULT_NUMBER_RADIX);	
		}	

		return self.addr;
	}

	getVMAInHex() {
		let self = this;
		if ('string' === typeof self.addr) {
			return self.addr;
		}

		let hexVal = new Number(self.addr);

		return hexVal.toString(DEFAULT_NUMBER_RADIX);
	
	}
	
	getOffset() {
		let self = this;
		let hexVal = Port.getOffsetInDL(self.addr, port.image);

		if (! hexVal) return hexVal;

		return parseInt(hexVal, DEFAULT_NUMBER_RADIX);
	}
	
	getOffsetInHex() {
		let self = this;
		return Port.getOffsetInDL(self.addr, port.image);
	}

	getShortSrcLoc() {
		let self = this;
    return path.basename(self.srcLoc);	
	}

	getAbsSrcLoc() {
    return this.srcLoc;	
	}

	getFuncName() {
    return this.funcName;	
	}
	
	getExecPoint() {
    return this.execPoint;	
	}

	toJSON() {
		let self = this;
		return {
			funcName: self.funcName,
			srcLoc: self.srcLoc,
			srcBasename: path.basename(self.srcLoc),
			execPoint: self.execPoint,
			addr: self.getVMAInHex(),
			image: self.image
		};
	}
}

class Interaction {

	constructor(src, tar, type, timestamp, pid, tid) {
		this.source = src;
		this.target = tar;
		this.type = type;
		this.timestamp = timestamp;
		this.pid = pid;
		this.tid = tid;
		this.seq;
	}
	
	static get QNAME() {
		return 'InteractionParser';
	}
	
	static get Priority() {
		return 300;
	}

	/**
	 * 
	 *   timestamp       gid     ppid     pid      tid     dir      caller          callee
	 *
	 *   1513570431      1000    14999    15000    15000    >    0x2ace57ad5f45    0x400811
	 */
	static get PATTERN() {
		return /^\s*([0-9]+)\s+[0-9]+\s+[0-9]+\s+([0-9]+)\s+([0-9]+)\s+([>|<])\s+([a-z0-9A-Z]+)\s+([0-9a-zA-Z]+)\s*$/gi;
	}

	/**
	 * @param String, the line item in the trace log
	 * @param opts, {
	 *   part: <Object> // current part
	 * }
	 *
	 * @return Promise
	 */
	static parse(line, opts, callback) {
		let timestamp, pid, tid, type, srcAddr, srcPort, targetAddr, targetPort;
	
		return Q().then(function() {
			let parsedReval = Interaction.PATTERN.exec(line.getContent());
			timestamp = parsedReval[1];
			pid = parsedReval[2];
			tid = parsedReval[3];
			type = parsedReval[4];
			srcAddr = parsedReval[5];
			targetAddr = parsedReval[6];
		}).then(function() {
			let currentPart = opts.processor.getCurrentPart();
			let ownerImage = currentPart.findImageByFuncVMA(srcAddr);

			return Port.parse(srcAddr, {image: ownerImage, part: currentPart}).then(function(port) {
				debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.green.bold('partial parsed') +': "left-side func-addr: ' + srcAddr + '" ==> Port: ' + JSON.stringify(port.toJSON()));
				srcPort = port;	
			});
		}).then(function() {
			let currentPart = opts.processor.getCurrentPart();
			let ownerImage = currentPart.findImageByFuncVMA(targetAddr);

			return Port.parse(targetAddr, {image: ownerImage, part: currentPart}).then(function(port) {
				debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.green.bold('partial parsed') + ': "right-side func-addr: ' + targetAddr + '" ==> Port: ' + JSON.stringify(port.toJSON()));
				targetPort = port;	
			});
		}).then(function() {
			//use colorful interaction to pair the req/resp
			let inter = new InteractionX(srcPort, targetPort, type, timestamp, pid, tid);
			let pairedInter = null;
			opts.processor.getCurrentPart().interactions.some(function(_inter) {
				if (_inter.isPaired(inter)) {
					pairedInter = _inter;
					return true;
				}
			});

			if (pairedInter) {
				inter.setColor(pairedInter.getColor());
			} else if (inter.isResponse()) {
				inter.setColor(DIAG_LINE_ERROR_COLOR);
			} else {
				let latestInter = opts.processor.getCurrentPart().getLatestInteraction();
				let preColor = latestInter && latestInter.getColor();
		    inter.setColor(getDiffColor(preColor));	
			}
			opts.processor.getCurrentPart().pushInteraction(inter);
			debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.green.bold('parsed') + ': "' + line.getContent() + '" ==> Interaction: ' + JSON.stringify(inter.toJSON()));
			return inter;
		}).fail(function(error) {
			console.error('Failed to parse interaction - "' + srcAddr + ' ' + type + ' ' + targetAddr + '" due to: ', error);
			throw error;
		}).nodeify(callback);
	}

	static canParse(line) {
		if (! line || ! line.getContent() || '' === line.getContent().trim()) {
	     return false;	
		}

		if (! Interaction.PATTERN.test(line.getContent())) {
		
			return false;
		}

		return true;
	}

	getSource() {
		return this.source; 
	}

	getTarget() {
		return this.target;	
	}

	getTimestamp() {
		return this.timestamp;
	}

	isRequest() {
		if ('>'	=== this.type.toLowerCase()) {
			return true;
		}

		return false;
	}

	isResponse() {
		if ( '<'	=== this.type.toLowerCase()) {
			return true;
		}
		return false;
	}

	getType() {
		return this.type;	
	}

	getTid() {
		return this.tid;	
	}

	getPid() {
		return this.pid;	
	}

	isPaired(inter) {
		let self = this;
		if (! inter) {
			return false;	
		}

		if (! inter.getSource().equalsTo(self.getSource()) ||
			  ! inter.getTarget().equalsTo(self.getTarget())
		) {
			return false;
		}
		
		if (inter.getPid() !== self.getPid() || 
			inter.getTid() !== self.getTid()) {
			return false;
		}

		if (self.getType() === inter.getType()) {
			return false;	
		}

		if (inter.isRequest() && inter.getTimestamp() > self.getTimestamp()){
			return false;	
		}

		if (inter.isResponse() && inter.getTimestamp() < self.getTimestamp()){
			return false;	
		}

		return true;
	}

	toJSON() {
		let self = this;
		return {
			source: self.getSource().toJSON(),
			target: self.getTarget().toJSON(),
			interactionType: self.getType(),
			timestamp: self.getTimestamp(),
			pid: self.getPid(),
			tid: self.getTid()
		};	
	}
}


class Image {
	constructor(path, vmaStart, vmaEnd) {
    this.fullPath= path;
		this.vmaStart = vmaStart;
		if ('string' === typeof this.vmaStart) {
	    this.vmaStart = parseInt(this.vmaStart, DEFAULT_NUMBER_RADIX);	
		}
		this.vmaEnd = vmaEnd;
		if ('string' === typeof this.vmaEnd) {
	    this.vmaEnd = parseInt(this.vmaEnd, DEFAULT_NUMBER_RADIX);	
		}

		// a cache to store the port owned by image,
		// key: value, key = addr
		this.ports = {};
	}

	static get QNAME() {
		return 'ImageParser';
	}
	
	static get Priority() {
		return 200;
	}

	/**
	 * Pattern: 
	 *  e.g:
	 *    2adf33535000-2adf33539000 r-xp 00000000 08:11 60690196                   /home/lizh/playground/calltracer/out/build/Debug/lib.target/libsimplelogger.so
	 */
	static get PATTERN() {
    return /^\s*([a-zA-Z0-9]+)-([a-zA-Z0-9]+)\s+r-xp\s+[a-zA-Z0-9]+\s+[0-9a-zA-Z]+:[0-9a-zA-Z]+\s+[0-9]+\s+([\S]+)\s*$/g;	
	}

	/**
	 * VMA layout info:
	 *
	 *  [Format]: 
	 *
	 *  start-end permissions offset major:minor inode image
	 *
	 *  [Details]:
	 *
	 *  start-end: start and end addresses of the VMA.
	 *
	 *  permissions: r (read), w (write), and x (execute). The p (private) and s (shared) flags indicate the type of memory mapping.
	 *
	 *  offset: the offset into the underlying object where the VMA mapping begins.
	 *
	 *  major:minor: the major and minor number pairs of the device holding the file that has been mapped.
	 *
	 *  inode: the inode number of the mapped file.
	 *
	 *  image: the name of the mapped file.
	 *
	 *  e.g:
	 *
	 *  00400000-00401000 r-xp 00000000 08:11 44834810                           /home/lizh/playground/calltracer/out/build/Debug/example
	 *  2adf3310d000-2adf33130000 r-xp 00000000 08:01 918655                     /lib/x86_64-linux-gnu/ld-2.19.so
	 *  2adf33332000-2adf33334000 r-xp 00000000 08:11 44966015                   /home/lizh/playground/calltracer/out/build/Debug/lib.target/libcalltracer.so
	 *  2adf33535000-2adf33539000 r-xp 00000000 08:11 60690196                   /home/lizh/playground/calltracer/out/build/Debug/lib.target/libsimplelogger.so
	 *  2adf3373b000-2adf338f9000 r-xp 00000000 08:01 918627                     /lib/x86_64-linux-gnu/libc-2.19.so
	 *
	 *  @param line
	 *  @param opts , {getCurrentPart: function() {...}) 
	 *  @param callback
	 *
	 *  @return Promise, resolve: Image
	 *
	 */
	static parse(line, opts, callback) {
		let imgPath  = null;
		let startVMA = null;
		let endVMA   = null;
		return Q().then(function() {
			let parsedReval = Image.PATTERN.exec(line.getContent());
			startVMA = parsedReval[1];
			endVMA = parsedReval[2];
			imgPath = parsedReval[3];

			if (opts.conf.fixlibpath && fs.existsSync(opts.conf.fixlibpath)) {
				debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + '), use fixlibpath to replace the orignal path: ' + colors.yellow.bold('"' + path.dirname(imgPath) + '" ==> "' + opts.conf.fixlibpath + '"'));
				let imgBasename = path.basename(imgPath);
				imgPath = path.join(opts.conf.fixlibpath, imgBasename);
			}

			let image = new ImageX(imgPath, startVMA, endVMA);
			opts.processor.getCurrentPart().pushImage(image);
			debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.green.bold('parsed') + ': "' + line.getContent() + '" ==> Image: ' + JSON.stringify(image.toJSON()));
			return image;
		}).fail(function(error) {
			console.error('Failed to parse image - "' + path.basename(imgPath) + '" due to :', error);
			throw error;
		}).nodeify(callback);
	}

	static canParse(line) {
		if (! line || ! line.getContent() || '' === line.getContent().trim()) {
	     return false;	
		}

		if (! Image.PATTERN.test(line.getContent())) {
		
			return false;
		}

		return true;
	}

	getBasename() {
		let baseName = path.basename(this.fullPath);
		return baseName;
	}
	
	getDir() {
		let dirname = path.dirname(this.fullPath);
		return dirname;
	}

	getFullPath() {
    return this.fullPath;	
	}

	getVMAStartAddr() {
		let self = this;
    if ('string' === typeof self.vmaStart) {
	    return parseInt(self.vmaStart, DEFAULT_NUMBER_RADIX);	
		}	

		return self.vmaStart;
	}
	
	getVMAStartAddrInHex() {
		let self = this;
    if ('string' === typeof self.vmaStart) {
	    return self.vmaStart;	
		}	

		let hexVal = new Number(self.vmaStart);
		return hexVal.toString(DEFAULT_NUMBER_RADIX);
	}

	getVMAEndAddr() {
		let self = this;
    if ('string' === typeof self.vmaEnd) {
	    return parseInt(self.vmaEnd, DEFAULT_NUMBER_RADIX);	
		}	

		return self.vmaEnd;
	}
	
	getVMAEndAddrInHex() {
		let self = this;
    if ('string' === typeof self.vmaEnd) {
	    return self.vmaEnd;	
		}	

		let hexVal = new Number(self.vmaEnd);
		return hexVal.toString(DEFAULT_NUMBER_RADIX);
	}

	/**
	 * Tell the lib type, so far, only support linux OS 
	 *
	 */
	isSharedLib() {
		let self = this;
		let extName = path.extname(self.getBasename()); 

		if ('.node' === extName.toLowerCase() || '.so' === extName.toLowerCase() || '.dll' === extName.toLowerCase()) {
			return true;
		}

		return false;
	}

	contains(funcAddr) {
		let self = this;
		if (! funcAddr) {
			return false;
		}

		if ( 'string' === typeof funcAddr) {
	    funcAddr = parseInt(funcAddr, DEFAULT_NUMBER_RADIX);	
		}

		if (funcAddr < self.getVMAStartAddr()) {
	    return false;	
		}

		if (funcAddr > self.getVMAEndAddr()) {
	    return false;	
		}

		return true;
	}

	setPort(addr, port) {
		if (! addr || ! port) return;

		let self = this;
		let key = addr;
    if ('number' === typeof key) {
			key = new Number(key);
			key = key.toString(DEFAULT_NUMBER_RADIX);
		}	
		self.ports[key] = port;
	}

	getPort(addr) {
		if (! addr) return;

		let self = this;
		let key = addr;
    if ('number' === typeof key) {
			key = new Number(key);
			key = key.toString(DEFAULT_NUMBER_RADIX);
		}	

		return self.ports[key];
	}

	toJSON() {
    let self = this;
		return {
	    isSharedLib: self.isSharedLib(),
			dir: self.getDir(),
			basename: self.getBasename(),
			vmaStart: self.getVMAStartAddrInHex(),
			vmaEnd: self.getVMAEndAddrInHex()
		};
	}
} 

class Part {
	constructor(pid) {
    this.pid = pid;	
		this.interactions = [];
		this.images = [];
		this.firstParticipatePort = null;
		this.lastParticipatePort = null;
		this.seqCursor = 0;
		this.reqSeqCursor = 0;
		this.stackCollapse = new StackCollapse(this);
	}

	/**
	 * Pattern of Part seperator:
	 * 
	 * e.g:
	 *
	 *   ***      Begin(pid: 15000)      ***
	 */
	static get PATTERN() {
		return /^\s*[\*]+\s*Begin\(pid:\s*([0-9]+)\s*\)\s*[\*]+\s*$/gi;
	}

	/**
	 *
	 * @return Promise, Part
	 */
	static parse(line, opts, callback) {
		return Q().then(function() {
			let parsedReval = Part.PATTERN.exec(line.getContent());
			let pid = parsedReval[1];
			let part = new PartX(pid);
			opts.processor.pushPart(part);
			debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.green.bold('parsed') + ': "' + line.getContent() + '" ==> Part: ' + JSON.stringify(part.toJSON()));
			return part;
		}).fail(function(error) {
			console.error('Failed to parse Part - "' + pid + '" due to :', error);
			throw error;
		}).nodeify(callback);
	}

	static get QNAME() {
		return 'PartParser';
	}

	static get Priority() {
		return 100;
	}

	/**
	 *
	 * @return Promise, Boolean, true: can parse, false: can't parse
	 */
	static canParse(line) {
		if (! line || ! line.getContent() || '' === line.getContent().trim()) {
	     return false;	
		}
		if (! Part.PATTERN.test(line.getContent())) {
		
			return false;
		}
		return true;
	}

	findImageByFuncVMA(funcVMA) {
		let self = this;
    if (! funcVMA) {
	    return;	
		}	

		let targetImg = null;
		self.images.some(function(image) {
			if (image.contains(funcVMA)) {
		    
				targetImg = image;
				return true;
			}
			return false;
		});

		return targetImg;
	}

	pushImage(image) {
		let self = this;
		if (image) {
			self.images.push(image); 
		}	
	}

	pushInteraction(inter) {
		let self = this;
		if (inter) {
			self.seqCursor ++;
			inter.seq = self.seqCursor;
			if (inter.isRequest()) {
		    self.reqSeqCursor ++;
				inter.reqSeq = self.reqSeqCursor;
			}
	    self.interactions.push(inter);	
			self.stackCollapse.append(inter);
		}
	}

	getLatestInteraction() {
    let self = this;
		let len = self.interactions.length;
		if (len  === 0) {
	    return;	
		}

		return self.interactions[len -1];
	}

	setFirstParticipatePort(port) {
    this.firstParticipatePort = port;	
	}
	
	setLastParticipatePort(port) {
    this.lastParticipatePort= port;	
	}

	getReqCount() {
    return this.reqSeqCursor;	
	}

	toJSON() {
		let self = this;
		let images = [];
		self.images.forEach(function(image) {
	    images.push(image.toJSON());	
		});

		let interactions = [];
		self.interactions.forEach(function(inter) {
	    interactions.push(inter.toJSON());	
		});
		return {
	    pid: self.pid,
			images: images,
			interactions: interactions
		};
	}
}

class InteractionX extends Interaction {
	constructor(src, tar, type, timestamp, pid, tid, color) {
		super(src, tar, type, timestamp, pid, tid);
		this.color = color || 'blue';
	}

	setColor(color) {
		this.color = color;
	}

	getColor() {
		return this.color;
	}

	/**
	 *
	 *     {
	 *       sImg: <String>,
	 *       sCode: <String>,
	 *       sFunc: <String>,
	 *       sLine: <Number>,
	 *       sVMA: <String>,
	 *       tImg: <String>,
	 *       tCode: <String>,
	 *       tFunc: <String>,
	 *       tLine: <String>,
	 *       tVMA: <String>,
	 *       timestamp: <String>,
	 *       isReq: <Boolean>,
	 *       color: <String>
	 *     }
	 */
	toJSONX(opts) {
		let json = {};
		let self = this;
		let seq = self.seq;
		let reqSeq = self.reqSeq;
		if (opts && opts.reqSeqPrefix) {
			reqSeq = opts.reqSeqPrefix + reqSeq;
			reqSeq = reqSeq.substr(reqSeq.length - opts.reqSeqPrefix.length);
		}
		json.tid = self.getTid();
		json.color = self.color; 
		json.sImg = self.getSource().image.getBasename();
		json.sCode = self.getSource().getShortSrcLoc();
		json.sAbsCode = self.getSource().getAbsSrcLoc();
		json.sFunc = self.getSource().getFuncName();
		json.sLine = self.getSource().getExecPoint();
		json.sVMA = self.getSource().getVMAInHex();
		json.tImg = self.getTarget().image.getBasename();
		json.tCode = self.getTarget().getShortSrcLoc();
		json.tAbsCode = self.getTarget().getAbsSrcLoc();
		json.tFunc = self.getTarget().getFuncName();
		json.tLine = self.getTarget().getExecPoint();
		json.tVMA = self.getTarget().getVMAInHex();
		json.isReq = self.isRequest() ? true : false;
		let timestamp = new Date(parseInt(self.getTimestamp()));
		timestamp = df(timestamp, DEFAULT_DATEFOMRAT_PATTERN);
		json.timestamp = timestamp;
		if (self.endTimestamp) {
			let endTimestamp = new Date(parseInt(self.endTimestamp));
		  endTimestamp = df(endTimestamp, DEFAULT_DATEFOMRAT_PATTERN);
			json.endTimestamp = endTimestamp;
		}
		json.seq = seq;;
		json.reqSeq = reqSeq;

		return json;
	}
}

class Stack {
	constructor(interactions, opts) {
		this._isFrozen = false;
		this.interactions = interactions || [];
		this.goForward = true;
		this.sid = opts.sid;
		this.pid = opts.pid;
		this.tid = opts.tid;
	}

	setSid(sid) {
   this.sid = sid;	
	}

	dump(opts) {
		let self = this;
		let reval = {sid: self.sid, pid: self.pid, tid: self.tid, interactions: []};
		self.interactions.forEach(function(i) {
			reval.interactions.push(i.toJSONX(opts));
		});
		return reval;
	}
}

class StackCollapse {
	constructor(part) {
		/**
		 * {
		 *   tid: []// stacks
		 * }
		 */
		this.stacks= {};  
		this.pid = part.pid;
		this.part = part;
	}

	getCurrentStack(tid) {
		const self = this;
		if (! self.stacks[tid] || self.stacks[tid].length === 0 ) {
			let stack = new Stack(null, {
		    pid: self.pid,
				tid: tid
			});
			self.stacks[tid] = [stack];
		}

		let currStack = self.stacks[tid][self.stacks[tid].length - 1];
		currStack.setSid('pid' + self.pid + '-tid' + tid + '-'  + (self.stacks[tid].length-1));
		return currStack;
	}

	append(interaction) {
		const self = this;

		if (interaction.isRequest()) {
			self._push(interaction);
		} else {
			self._pop(interaction);
		}
	}

	_push(interaction) {
		const self = this;
		const tid = interaction.tid;
		let currentStack = self.getCurrentStack(tid);

		if (currentStack.goForward) {
			currentStack.interactions.push(interaction);
			return;
		}

		currentStack._isFrozen = true;

		let uncompletedCount = 0;
		currentStack.interactions.some(function(inter) {
			if (inter._isCompleted) {
		     return true;	
			}
			uncompletedCount ++;
		});

		let respinStack = null;
		if (0 === uncompletedCount) {
	    respinStack = new Stack(null, {pid: self.pid, tid: tid});	
		} else {
			let uncompletedInteractions = [];

			for (let i = 0; i < uncompletedCount; i++) {
				uncompletedInteractions.push(currentStack.interactions[i]);
			}
			respinStack = new Stack(uncompletedInteractions, {pid: self.pid, tid: tid});
		}
		respinStack.interactions.push(interaction);
		self.stacks[tid].push(respinStack);
	}

	_pop(interaction) {
		const self = this;
		const tid = interaction.tid;

		let currentStack = self.getCurrentStack(tid);
		currentStack.goForward = false;
		let nextUnpaired = currentStack.interactions.length - 1;

		while (nextUnpaired > 0 && currentStack.interactions[nextUnpaired]._isCompleted) {
	   nextUnpaired --;	
		}

		if (nextUnpaired === -1 || ! interaction.isPaired(currentStack.interactions[nextUnpaired])) {
			console.error('Unmatched response interaction: ', interaction, currentStack.interactions[nextUnpaired]);
			return;
		}
		currentStack.interactions[nextUnpaired]._isCompleted = true;
		currentStack.interactions[nextUnpaired].endTimestamp = interaction.timestamp;
	}

	_totalReqCount() {
    const self = this;
		return self.part.getReqCount();
	}

	dump() {
		const self = this;
		let reval = {pid: self.pid, stacks: []};
		let reqSeqPrefix = '';
		for (let i=0; i < (''+self._totalReqCount()).length; i++) {
	    reqSeqPrefix = reqSeqPrefix + '0';	
		}

		Object.keys(self.stacks).forEach(function(k) {
			let stacksPerThread = self.stacks[k]; 
			stacksPerThread.forEach(function(s) {
				reval.stacks.push(s.dump({reqSeqPrefix: reqSeqPrefix}));	
			});
		});

		return reval;
	}
}

class PartX extends Part {
	constructor(pid) {
    super(pid);	
		this.participateCodeStack = [];
	}
	
	setFirstParticipatePort(port) {
		super.setFirstParticipatePort(port);

		this.participateCodeStack.push(
	    {
				imgBasename: port.image.getBasename(),
		    shortSrcLoc: port.getShortSrcLoc(),
				absSrcLoc: port.getAbsSrcLoc()
		  }	
		);
	}
	
	setLastParticipatePort(port) {
		super.setLastParticipatePort(port);
		let isParticipated = false;
		let imgBasename = port.image.getBasename();
		let shortSrcLoc = port.getShortSrcLoc();
		let absSrcLoc = port.getAbsSrcLoc();

		this.participateCodeStack.some(function(pcs) {
			if (pcs.imgBasename === imgBasename && 
				shortSrcLoc === pcs.shortSrcLoc && 
				absSrcLoc === pcs.absSrcLoc) {
		    isParticipated = true;
				return true;
			} 
		});

		if (! isParticipated) {
	    this.participateCodeStack.push({
				imgBasename: imgBasename,
		    shortSrcLoc: shortSrcLoc,
				absSrcLoc: absSrcLoc 
			});	
		}
	}

	toJSONX() {
		let self = this;
		let images = [];
		self.images.forEach(function(image) {
	    images.push(image.toJSONX());	
		});

		let interactions = [];
		self.interactions.forEach(function(inter) {
	    interactions.push(inter.toJSONX());	
		});


		let startTime = self.interactions[0] && self.interactions[0].getTimestamp();
		startTime = startTime && new Date(parseInt(startTime));
		startTime = df(startTime, DEFAULT_DATEFOMRAT_PATTERN);
		let endTime = self.interactions[0] && self.interactions[self.interactions.length - 1].getTimestamp();
		endTime = endTime && new Date(parseInt(endTime));
		endTime = df(endTime, DEFAULT_DATEFOMRAT_PATTERN);

		let firstSrc = self.participateCodeStack[0];
		let lastSrc = self.participateCodeStack[self.participateCodeStack.length - 1];
		return {
	    pid: self.pid,
			startTime: startTime,
			endTime: endTime,
			firstImg: firstSrc.imgBasename,
			firstCode: firstSrc.shortSrcLoc,
			firstAbsCode: firstSrc.absSrcLoc,
			lastImg: lastSrc.imgBasename,
			lastCode: lastSrc.shortSrcLoc,
			lastAbsCode: lastSrc.absSrcLoc,
			images: images,
			interactions: interactions
		};
	}
}

class ImageX extends Image {
	constructor(path, vmaStart, vmaEnd) {
    super(path, vmaStart, vmaEnd);	
	}
	
	toJSONX() {
		let json = super.toJSON();
		return json;
	}
}

/**
 * Line Processor
 *
 */
class LineProcessor{
	constructor (conf) {
		this.failed = [];
		this.parts = []; 
		this.parsedLineCount = 0;
		this.conf = conf;
	}

	static get ELEMENT_TYPES () {
		return [Part, Image, Interaction];	
	}

	static resolveParser(line) {
		let targetParser = null;
		LineProcessor.ELEMENT_TYPES.some(function(parser) {
			if (parser.canParse(line)){
				targetParser = parser;
				return true;
			}
		});
		return targetParser;
	}

	parse(line, callback) {
		let self = this;
		let parser = line.getParser();

		try {
			let opts = {
		    conf: self.conf	
			};
			opts.processor = self;
			return parser.parse(line, opts).then(function(reval) {
				self.parsedLineCount++;
			}).fail(function(error) {
				console.error('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.red.bold('failed to parse by ' + parser.QNAME), error);
				self.failed.push(line);	
			}).nodeify(callback);
		} catch (error) {
			console.error('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.red.bold('failed to get start parsing,  due to: '), error);
			self.failed.push(line);	
			return Q().nodeify(callback);
		}
	}

	getCurrentPart() {
		let self = this;
		if (self.parts.length === 0) {
			return null;	
		}
		return self.parts[self.parts.length - 1];
	}

	pushPart(part) {
	  let self = this;
		self.parts.push(part);
	}

	aggregate() {
		let self = this;
		let parts = [];
		self.parts.forEach(function(part) {
	    parts.push(part.toJSON());	
		});
		return {
	    parts: parts
		};
	}

  aggregateX() {
		let self = this;
		let parts = [];
		self.parts.forEach(function(part) {
	    parts.push(part.toJSONX());	
		});
		return {
	    parts: parts
		};
	} 

	dumpStackCollapse() {
		let self = this;
		let reval = {parts: []};	
		self.parts.forEach(function(p) {
			reval.parts.push(p.stackCollapse.dump());
		});

		return reval;
	}

	failedLines() {
    return this.failed;	
	}

	getParsedLineCount() {
    return this.parsedLineCount;	
	}
}

/**
 * Abstract class for  base phased task implementation
 * 
 * For each specific task, the 'getName' method is mandatory to be implemented. For others 3 methods, 
 * either overwrite the methods or just delegate to this basic implementation.  
 *  
 * @param {object} context
 */
class BaseTask {
	constructor (context) {
		this.context = context;
	}

	/**
	 * Get the task name
	 * 
	 * @returns name
	 */
	getName() {
		throw new Error('Unsupported method in abstract base abstract interceptor');
	}

	/**
	 * Invoke for normal action asynchronously
	 * @param {function}, function(error), if error presented, do with error, otherwise, do successfully
	 */
	doAsync(done){
		// do nothing for abstract method
		throw new Error('Unsupported method in abstract base abstract interceptor');
	}

	/**
	 * Invoke for undo action asynchronously
	 * @param {function}, function(error), if error presented, undo with error, otherwise, undo successfully
	 */
	undoAsync(done) {
		// do nothing for abstract method
		throw new Error('Unsupported method in abstract base abstract interceptor');
	}

	/**
	 * Cancel task execution
	 */ 
	cancel() {
		this._cancel = true;
	}

	/**
	 * Check is task cancelled
	 */ 
	isCancelled() {
		return this._cancel;
	} 
}

// timeout to 120 mins
let ASYNC_TIMEOUT = 120*60*1000;

/**
 * Tasks management, add the task by order(phase based task invocation), 
 * control the cursor to indicate current processing task
 */
class TasksMgrt {
	constructor () {
		this.cursor = -1;
		this.tasks = []; 
		this.continueOnError = false;
		this.rootCause = null;
		this._onProcessing = false;
	}

	/**
	 * Static method for task validation
	 */
	static isValidTask(task) {
		if (! task) return false;

		if (!task.getName || 
			!task.doAsync ||
			!task.undoAsync) return false;

		if (!(typeof task.getName === 'function') || 
			!(typeof task.doAsync === 'function') ||
			!(typeof task.undoAsync === 'function')) 
			return false

		return true;
	}

	/**
	 * Add a new task to task list
	 * 
	 * @param {Object}, <Task>
	 */
	addTask(task) {
		if (! TasksMgrt.isValidTask(task)) {
			throw new Error('Invalid Task: ', task);
		}

		this.tasks.push(task);
	}

	/**
	 * Remove task to task list
	 * 
	 * @param {Object}, <Task|string|number>
	 */
	removeTask(task) {
		var expectedKey = null;
		if ('string' === typeof task || 'number === typeof task') {
			expectedKey = task;
		} else {
			if (! TasksMgrt.isValidTask(task)) {
				throw new Error('Invalid Task: ', task);
			}

			expectedKey = task.getName();
		}

		for (var i= this.tasks.length; i >=0; i--) {
			if (this.tasks[i].getName() === expectedKey) {
				this.tasks.splice(i, 1);
			}
		}
	}

	/**
	 * Tell whether has next task in task list
	 *
	 * @return {Boolean}, true|false
	 */
	hasNext() {
		if (this.cursor >= this.tasks.length-1) return false;
		return true;
	}

	/**
	 * Get next task in task list
	 *
	 * @return {Task}, the next task in task queue
	 */
	next() {
		if (! this.hasNext()) return null;

		++this.cursor;
		return this.tasks[this.cursor];
	}

	/**
	 * Tell whether has previous task in task list
	 *
	 * @return {Boolean}, true|false
	 */
	hasPrevious() {
		if (this.cursor <= 0) return false;

		return true;
	}

	/**
	 * Get previous task in task list
	 *
	 * @return {Task}, the next task in task queue
	 */
	previous() {
		if (! this.hasPrevious()) return null;

		--this.cursor;
		return this.tasks[this.cursor];
	}

	/**
	 * Get current task in task list
	 *
	 * @return {Task}, the next task in task queue
	 */
	current () {
		return this.tasks[this.cursor];
	}

	/**
	 * Internal method which call by each task for the task execution navigation
	 *
	 */
	_done(error) {
		let self = this;

		if (error || self.continueOnError) {

			if (! this.continueOnError) {
				this.rootCause = error;
				this.continueOnError = true;
				console.debug('Error occurs for task ' + self.current().getName() +  ' execution, due to: ', error);
				self.current().undoAsync(self._done.bind(self));
				return;
			}

			if (self.hasPrevious()) {
				self.previous().undoAsync(self._done.bind(self));
				return;
			} 
			this._onProcessing = false;
			self.deferred.reject(self.rootCause);
			return;
		}


		if (self.hasNext()) {
			self.next().doAsync(self._done.bind(self));
			return;
		} 

		this._onProcessing = false;
		self.deferred.resolve();	
	}


	/**
	 * Process the tasks asynchronously
	 *
	 * @return {promise}, the result of processing
	 */
	processAsync(context, callback, timeout) {
		let self = this;

		self.deferred = Q.defer();
		// set default promise timeout
		if (! timeout) {
			timeout = ASYNC_TIMEOUT;
		}
		self.deferred.promise.timeout(timeout);

		if (self.hasNext()){
			this._onProcessing = true;
			self.next().doAsync(self._done.bind(self));
		} else {
			self.deferred.reject(new Error('No task registered!'));
		}

		return self.deferred.promise.nodeify(callback);
	}

	getTasks() {
		return this.tasks;
	}

	isOngoing() {
		return this._onProcessing;
	}
}

class SequencingLineParseTask extends BaseTask {

	constructor(context, line) {
    super(context);	
		this.line = line;
	}
	
	undoAsync(done) {
		done();
	}

  doAsync(done) {
		let self = this;
		let processor = self.context.processor;

		return processor.parse(self.line).then(function() {
			done();
		}).fail(function(error) {
			console.error('Failed to perform sequencing-line-parse-task, due to:', error);
			done(error);
		});
	}
}

class GroupPriorityJobQTask extends BaseTask {
	
	constructor(context) {
		super(context);
		// groups is the container of 
		// jobQueues, jobQueues is a Object type, priority is the key, and 
		// value is an array of lines to parse 
		this.groups = [];
		this.sortedQ = [];

	}

	getCurrentGroup() {
		const self = this;
    if (self.groups.length === 0) {
			return;
		}	

		return self.groups[self.groups.length - 1];
	}

	addJob(line) {
		const self = this;

		if (! line) return;
		if (! line.getParser()) {
			debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.yellow.bold('ignored') + ': "' + line.getContent() + '"');
			return;
		}

		if (line.getParser().QNAME === Part.QNAME) {
			self.groups.push({});
		}

		const jobQueues = self.getCurrentGroup();

		let priority = line.getParser().Priority || DEFAULT_JOB_PRIORITY;
		let queue = jobQueues[priority];
		if (! queue) {
	    queue = [];	
			jobQueues[priority] = queue;
		}
		queue.push(line);
	}
	
	undoAsync(done) {
		done();
	}
	
  doAsync(done) {
		const self = this;
		const workerTaskMgrt = new TasksMgrt(); 
		let workerCtx = {
			processor: self.context.processor,
			conf: self.context.conf
		};

		self.groups.forEach(function(jobQueues) {
			let priorites = Object.keys(jobQueues).sort(function(l, r) {
				return l - r;	
			});

			priorites.forEach(function(key) {
				self.sortedQ = self.sortedQ.concat(jobQueues[key]);	
			});

			self.sortedQ.forEach(function(line) {
				workerTaskMgrt.addTask(new SequencingLineParseTask(workerCtx, line));
			});
		});
			
		workerTaskMgrt.processAsync(workerCtx, function(error, result) {
			if (error) {
				console.error('Failed to perform sequencing-logfile-parse-task, due to:', error);
				return  done(error);	
			}
			done();
		});
	}

}

class SequencingLogFileParseTask extends BaseTask {
	constructor(context, logFile) {
    super(context);	
		this.logFile = logFile;
	}
	
	undoAsync(done) {
		done();
	}

  doAsync(done) {
		const self = this;
		const processor = self.context.processor;

		let status = self.context.status;
		let conf = self.context.conf;

		let slpTaskMgrt = new TasksMgrt(); 
		let subCtx = {
			processor: processor,
			conf : conf
		};
		let gpjqTask = new GroupPriorityJobQTask(subCtx);
		slpTaskMgrt.addTask(gpjqTask);

		let rl = readline.createInterface({
			input: fs.createReadStream(self.logFile),
			crlfDelay: Infinity
		});
		let position = 0;

		rl.on('line', function(l){
			position ++;
			let line = new Line(position, self.logFile, l);

			if (line.getParser() && line.getParser().QNAME === Interaction.QNAME) {
		    status.readInteraction ++;	
				if (conf.skip > 0 && status.readInteraction <= conf.skip) {
					debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.blue.bold('skipped') + ': "' + line.getContent() + '", since skip conf: ' + conf.skip + ', current course position: '+ status.readInteraction);
					return;
				}

				if (conf.limit !== 'unlimited' && status.parsedInteraction >= conf.limit) {
					debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.blue.bold('skipped') + ': "' + line.getContent() + '", since limit conf: ' + conf.limit + ', current parsed count: ' + status.parsedInteraction);
					return;
				}
				debug('Line-' + line.getPosition() + '(' + path.basename(line.getLogFile()) + ') is ' + colors.blue.bold('enqueued') + ': "' + line.getContent());
				status.parsedInteraction ++;
			}

			gpjqTask.addJob(line);
		});
		
		rl.on('close', function(){
			slpTaskMgrt.processAsync(subCtx, function(error, result) {
				if (error) {
					console.error('Failed to perform sequencing-logfile-parse-task, due to:', error);
			    return  done(error);	
				}

				done();
			});
		});
	}
}

class SeqDiagGenerator extends BaseTask {
	constructor(context) {
    super(context);	
	}
	
	undoAsync(done) {
		done();
	}

  doAsync(done) {
		const self = this;
		const conf = self.context.conf;

		const processor = self.context.processor;
		const descFile = path.join(conf.outdir, OUT_SEQ_DESC_FILE);
		const jsonFile = path.join(conf.outdir, OUT_SEQ_JSON_FILE);
		const tempalte = fs.readFileSync(TEMPLATE_PATH, 'utf8');	
		const pngFile = path.join(conf.outdir, OUT_SEQ_PNG_FILE);

		fs.writeFileSync(jsonFile, JSON.stringify(processor.aggregateX()), 'utf8');
		let reval = Mustache.render(tempalte, processor.aggregateX());
		fs.writeFileSync(descFile, reval, 'utf8');

		if (conf.textual) {
	    done();
			return reval;
		}

		let seqdiag_cmd = new CMDExecutor(SEQDIAG_CMD);
		// let params = ['--no-transparency','-o', pngFile, descFile];
		let params = ['-o', pngFile, descFile];

		return seqdiag_cmd.exec(params).then(function(output) {
			debug('Run seqdiag command,  params:\n', params, '\n output:\n', '"' + output + '"');
			done();
			return reval;
		}).fail(function(error) {
	   console.error('Failed to run seqdiag command, due to ', error); 	
			done(error);
		});
	}
}

class DiagramsGenerator extends BaseTask {
	constructor(context) {
    super(context);	
	}
	
	undoAsync(done) {
		done();
	}

  doAsync(done) {
		const self = this;
		const conf = self.context.conf;

		const processor = self.context.processor;
		const descFile = path.join(conf.outdir, OUT_SEQ_DIAGRAMS_DESC_FILE);
		const jsonFile = path.join(conf.outdir, OUT_SEQ_DIAGRAMS_JSON_FILE);
		const tempalte = fs.readFileSync(DIAGRAMS_TEMPLATE_PATH, 'utf8');	
		const svgFile = path.join(conf.outdir, OUT_SEQ_SVG_FILE);

		fs.writeFileSync(jsonFile, JSON.stringify(processor.aggregateX()), 'utf8');
		let reval = Mustache.render(tempalte, processor.aggregateX());
		fs.writeFileSync(descFile, reval, 'utf8');

		if (conf.textual) {
	    done();
			return reval;
		}

		let diagrams_cmd = new CMDExecutor(DIAGRAMS_CMD_LAUNCHER, DIAGRAMS_CMD_CWD);
		// let params = ['--no-transparency','-o', pngFile, descFile];
		let params = ['/usr/local/bin/npm', 'run', DIAGRAMS_CMD, '--', 'sequence',  descFile, svgFile];

		return diagrams_cmd.exec(params).then(function(output) {
			debug('Run seqdiag command,  params:\n', params, '\n output:\n', '"' + output + '"');
			done();
			return reval;
		}).fail(function(error) {
	   console.error('Failed to run seqdiag command, due to ', error); 	
			done(error);
		});
	}
}

class FlameGraphGenerator extends BaseTask {
	constructor(context) {
    super(context);	
	}
	
	undoAsync(done) {
		done();
	}

  doAsync(done) {
		const self = this;
		const conf = self.context.conf;
		debug('Flamegraph generator Begin');

		const processor = self.context.processor;
		const jsonFile = path.join(conf.outdir, OUT_SEQ_STACKCOLLAPSE_JSON_FILE);
		const descFile = path.join(conf.outdir, OUT_SEQ_STACKCOLLAPSE_DESC_FILE);
		const tempalte = fs.readFileSync(STACKCOLLAPSE_TEMPLATE_PATH, 'utf8');	
		const svgFile = path.join(conf.outdir, OUT_SEQ_FLAMEGRAPH_FILE);

		debug('Writing json to: ', jsonFile);
		fs.writeFileSync(jsonFile, JSON.stringify(processor.dumpStackCollapse()), 'utf8');
		debug('Render to: ', tempalte);
		let reval = Mustache.render(tempalte, processor.dumpStackCollapse());
		debug('Writing desc to: ', descFile);
		fs.writeFileSync(descFile, reval, 'utf8');
		
		if (conf.textual) {
	    done();
			return reval;
		}

		let out = fs.openSync(svgFile, 'w+');
		let opts = {
	   stdio: ['pipe', out, 'pipe']
		};
		
		let flamegraph_cmd = new CMDExecutor(FLAMEGRAPH_CMD_LAUNCHER, null, opts);
		let params = [FLAMEGRAPH_CMD, '--countname="Func-Trace"',  descFile];

		return flamegraph_cmd.exec(params).then(function(output) {
			debug('Run flamegraph generator command,  params:\n', params, '\n output:\n', '"' + output + '"');
		  fs.closeSync(out);	
			debug('Flamegraph generator End');
			done();
			return reval;
		}).fail(function(error) {
	   console.error('Failed to run seqdiag command, due to ', error); 	
			done(error);
		});

	}
}
//=========================================================
//                   Main 
//=========================================================

const logs = [];

program
	.version('1.0.0')
	.usage('[options] <logfile> ...')
	.option('-o, --outdir [outdir]', 'Output directory, default to current working directory')
	.option('-l, --limit [limit]', 'Limit count of the interactions, default is unlimited')
	.option('-s, --skip [skip]', 'Skip parsing of the interactions with specified count, default is 0')
	.option('-v, --visualizer [visualizer]', 'The visaulizer used to present the call stack, "framegraph", "seqdiag" and "diagrams" are supported,  default is "framegraph", "all" means generate all supported views')
	.option('-t, --textual [textual]', 'Only generate textual description, does not generate png, default is false')
	.option('-f, --fixlibpath [fixlibpath]', 'Specify a fixed lib path in case of the machine of programming running is not same as the iseq processing, default is null')
	.parse(process.argv);

if (! program.args || program.args.length === 0) {
	let files = fs.readdirSync(process.cwd());
	program.args = []
	files.forEach(function(f) {
		if (TRACE_FILE_PATTERN.test(f)) {
			program.args.push(f);
		}
		TRACE_FILE_PATTERN.lastIndex = 0;
	});
}

if (! program.args || program.args.length === 0) {
	console.error(colors.red('[Error]: ') + 'Missing arguments of log file(s) to translate!'); 
	program.outputHelp();
	process.exit(1);
}

program.args.forEach(function (logFile) {
	if (! path.isAbsolute(logFile)) {
		logFile = path.resolve(process.cwd(), logFile);
	}
	logs.push(logFile);
	if (! fs.existsSync(logFile)) {
		console.error(colors.red('[Error]: ') + 'log file does not exist - "' + logFile + '"');	
		program.outputHelp();
		process.exit(1);
	}
});

let conf = {
	'outdir': (program.outdir ? program.outdir : process.cwd()),
	'limit': (program.limit ? parseInt(program.limit) : 'unlimited'),
	'skip': (program.skip? parseInt(program.skip) : 0),
	'textual': (program.textual ? program.textual : false),
	'fixlibpath': (program.fixlibpath ? program.fixlibpath : null),
	'visualizer': (program.visualizer ? program.visualizer : 'flamegraph')
};

if (! path.isAbsolute(conf.outdir)) {
	conf.outdir = path.resolve(process.cwd(), conf.outdir);
}

if (! fs.existsSync(conf.outdir)) {
	console.error(colors.red('[Error]: ') + 'out directory does not exist - "' + conf.outdir + '"');	
	program.outputHelp();
	process.exit(1);
}

if (conf.fixlibpath && ! path.isAbsolute(conf.fixlibpath)) {
	conf.fixlibpath = path.resolve(process.cwd(), conf.fixlibpath);
}

if (conf.fixlibpath && ! fs.existsSync(conf.fixlibpath)) {
	console.error(colors.red('[Error]: ') + 'fix lib path does not exist - "' + conf.fixlibpath+ '"');	
	program.outputHelp();
	process.exit(1);
}

if ('string' === typeof conf.textual) {
	if ('true' === conf.textual.toLowerCase()) {
		conf.textual = true;	
	} else {
		conf.textual = false;	
	}
}

console.log('\n*******************************************************');
console.log('==>  LOGS: "' + logs+ '"');
console.log('==>  OUT DIR: "' + conf.outdir+ '"');
console.log('==>  LIMIT: "' + conf.limit+ '"');
console.log('==>  SKIP: ' + conf.skip);
console.log('==>  TEXTUAL: ' + conf.textual);
console.log('==>  VISUALIZER: ' + conf.visualizer);
console.log('*******************************************************\n\n');

const context = {};
const tm = new TasksMgrt();
const lp =  new LineProcessor(conf);

context.processor = lp;
context.conf = conf;
context.status = {
  readInteraction: 0,
	parsedInteraction: 0
};

logs.forEach(function(log) {
	let seqLogfilePT = new SequencingLogFileParseTask(context, log);
	tm.addTask(seqLogfilePT);
});

if ('all' === conf.visualizer.toLowerCase() || 'seqdiag' === conf.visualizer.toLowerCase()) {
	tm.addTask(new SeqDiagGenerator(context));
}

if ('all' === conf.visualizer.toLowerCase() || 'diagrams' === conf.visualizer.toLowerCase()) {
	tm.addTask(new DiagramsGenerator(context));
}

if ('all' === conf.visualizer.toLowerCase() || 'flamegraph' === conf.visualizer.toLowerCase()) {
	tm.addTask(new FlameGraphGenerator(context));
}

tm.processAsync(context, function(error, result) {
	console.log('DONE');
});

